
/*
* Team Id: eYRC#NS3944
* Author List: Sagar Narkhede , Omkar Sutar, Pooja Katkar, Ashlesha Borade 
* Filename:ROBOT_#NS3944
* Theme: Nutty Squirrel(eYRC)
*Filename	:	colorsence.h
*Functions     :rgb_port_config (void),color_sensor_pin_config(void),color_sensor_pin_interrupt_init(void),filter_red(void), filter_green(void), filter_blue(void),filter_clear(void),color_sensor_scaling(),red_read(void),
                 green_read(void),blue_read(void),red_led_on(),green_led_on(), blue_led_on(),led_off(void),rgb_on(void),colour_detect().			  
*Global_variable : 	volatile unsigned int red,  volatile unsigned int blue, volatile unsigned  int no_ff ,volatile unsigned int green, unsigned  int pulse,unsigned char ADC_Conversion(unsigned char Ch),int nuts_position[10],unsigned int count=0.
*/




#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <math.h>		
#include "my_delay.h"			//included to support power function
volatile unsigned int red;       // variable to store the pulse count when read_red function is called.
volatile unsigned int blue;      // variable to store the pulse count when read_blue function is called.
volatile unsigned  int no_ff;   // variable to store the pulse count when no_filter  function is called.
volatile unsigned int green;    // variable to store the pulse count when read_green function is called.
volatile unsigned  int pulse =0;//to keep the track of the number of pulses generated by the color sensor.


int color; //to store color which is  detected

#define R 1
#define B 2
#define G 3
#define E 0


void green_led_on(void);   //Green led glow when green nuts detected.
void red_led_on(void);     //Red led glow when red nuts detected.
void blue_led_on(void);    //Blue led glow when blue nuts detected.
void colour_detect();  //to detect R,G,B color of nuts.
void led_off(void);         // No nuts are detected.

unsigned char ADC_Conversion(unsigned char Ch);

int nut_no;
unsigned int count=0;
int nuts_position[10];

void rgb_port_config (void)

{
	DDRH = 0XFF; //set H port as output for RGB led 
	PORTH = 0xFF; //initiall set all bits of port H 
}

void color_sensor_pin_config(void)
{
	
DDRD  = 0xFE; //set PD0 as input for color sensor output
PORTD = 0x01;//Enable internal pull-up for PORTA 0 pin
DDRB  = 0xFF;//port for scalling and filletr selecting
}


void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
	EICRA =0x02;  // INT0 is set to trigger with falling edge
	EIMSK =0x01;  // Enable Interrupt INT0 for color sensor
	sei(); // Enables the global interrupt
}

//ISR for color sensor
ISR(INT0_vect) // Pass the timer number in place of n in INTn_vect
{
	pulse++;//increment on receiving pulse from the color sensor
}


//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	 //set S2 low
	 //set S3 low
	 PORTB =  0x10;
	
}

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	 //set S2 High
	//set S3 High
	PORTB =  0xD0;
	
}
void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	//set S2 low
	//set S3 High
	PORTB =  0x90;
	
}

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	//set S2 High
	//set S3 Low
	PORTB =  0x50;
}

void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	
	//set S0 high
	//set S1 high
    PORTB =  0x10;
	
	
}



void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	filter_red(); //select red filter
	pulse=0; //reset the count to 0
	_delay_ms(4300); 
	red = pulse;  //store the count in variable called red

}

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
    filter_green();  //select green filter
	pulse=0;         //reset the count to 0
	_delay_ms(6800);  
	green = pulse;   //store the count in variable called green
}

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	filter_blue(); //select blue filter
	pulse=0; //reset the count to 0
	_delay_ms(5900); 
	blue = pulse;  //store the count in variable called blue
	
}

////////To detect the appropriate colour & glow respective RGB colour//////////////

void red_led_on()
{
	PORTH = 0xEF;//RED
	_delay_ms(150);
	
}

void green_led_on()
{
	PORTH = 0xDF; //GREEN
	_delay_ms(150);
	
}

void blue_led_on()
{
	PORTH = 0xBF;// BLUE
	_delay_ms(150);
	
}

void led_off(void)
{
	PORTH = 0xFF; //NO color
}
void rgb_on(void)
{
	 if ((red < 930) && (blue < 930) && (green < 930))
	{
		
		nuts_position[nut_no]=E;
		lcd_cursor(2,15);
		lcd_string("E");
		led_off();
		
	}
	
	else if ((red > green) && (red > blue))
	{
		
		nuts_position[nut_no]=R;
		//lcd_cursor(2,15);
		//lcd_string("R");
		red_led_on();
		delay(500);
		led_off();
		
	}
	else if((green > red) && (green > blue))
	 {
		 
		 nuts_position[nut_no]=G;
		 //lcd_cursor(2,15);
		 //lcd_string("G");
		 green_led_on();
		 delay(500);
		 led_off();
		
	}
	else if ((blue > red ) && (blue > green))
	{
		nuts_position[nut_no]=B;
		//lcd_cursor(2,15);
		//lcd_string("B");
		blue_led_on();
		delay(500);
		led_off();
		
	}
	else 
	{
		lcd_cursor(2,15);
		lcd_string("F");
	    led_off();
	
	}
}
//// To detect the RGB colour///

void colour_detect()
{

red_read();
red=(red);
filter_clear();

char str[10] = {0};
itoa(red, str ,10);
lcd_cursor(2,1);
lcd_string(str);
lcd_cursor(1,1);
lcd_string(" R ");


green_read();
green=(green);
filter_clear();
char str1[10] = {0}; 
itoa(green, str1 ,10);
lcd_cursor(2,5);
lcd_string(str1);
lcd_cursor(1,5);
lcd_string(" G ");

blue_read();
blue=(blue);
filter_clear();

char str2[10] = {0};
itoa(blue, str2 ,10);
lcd_cursor(2,10);
lcd_string(str2);
lcd_cursor(1,10);
lcd_string(" B ");

}





